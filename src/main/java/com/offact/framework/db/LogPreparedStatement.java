package com.offact.framework.db;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.BatchUpdateException;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;

/**
 * SQL을 로그에 남기는 PreparedStatement
 * @author pat
 *
 */
public class LogPreparedStatement
    implements PreparedStatement {

	private final Logger logger = Logger.getLogger(getClass());
	
    private static final String LINE    =
        System.getProperty("line.separator");

    private     String              	pquery;
    private     PreparedStatement   	pstmt;
    protected   Map<Integer, Object>	params;
    private     String              	queryId;

    /**
     */
    public LogPreparedStatement(String              pquery,
                                PreparedStatement   pstmt,
                                String queryId) {

        this.pquery     = pquery;
        this.pstmt      = pstmt;
        this.params     = new HashMap<Integer, Object>();
        this.queryId	= queryId;
    }

    /**
     */
    protected void doLog() {
    	
    	if (!logger.isDebugEnabled()) {
    		return;
    	}
    	
        StringBuffer    sb;

        sb  = new StringBuffer();

        sb.append("Query ID [").append(queryId).append("] :").append(LINE);
        if (this.pquery != null) {
            if (this.params.size() == 0) {
                sb.append(this.pquery).append(LINE);
            } else {
                String[]    qs;
                int         to;

                qs  = this.pquery.split("\\?");
                to  = qs.length - 1;
                for (int i=0; i<=to; i++) {
                    Object  param;
                    Integer key;

                    sb.append(qs[i]);
                    key     = Integer.valueOf(i+1);
                    param   = this.params.get(key);
                    if (param == null) {
                        if (this.params.containsKey(key)) {
                            sb.append("NULL");
                        } else if (i!=to) {
                            sb.append("[NotAssgin]");
                        }
                    } else {
                        if (param instanceof Number) {
                            sb.append(param.toString());
                        } else if (param instanceof String) {
                            sb.append("'").append(param).append("'");
                        } else {
                            sb.append("[").append(param).append("]");
                        }
                    }
                }
            }
        }
        
        logger.debug(sb.toString());
    }
    
    protected void doLog(String query) {
        StringBuffer    sb;

    	if (!logger.isDebugEnabled()) {
    		return;
    	}
        sb  = new StringBuffer();

        sb.append("Query  :").append(LINE);
        sb.append(query);

        this.logger.debug(sb.toString());
    }
    
    /**
     * Executes the SQL query in this <code>PreparedStatement</code> object
     * and returns the <code>ResultSet</code> object generated by the query.
     *
     * @return a <code>ResultSet</code> object that contains the data
     *   produced by the query; never <code>null</code>
     * @throws SQLException if a database access error occurs or the SQL
     *   statement does not return a <code>ResultSet</code> object
     */
    public ResultSet executeQuery()
        throws SQLException {
        ResultSet   rv;

        this.doLog();
        rv  = this.pstmt.executeQuery();
        return rv;
    }

    /**
     * Executes the SQL statement in this <code>PreparedStatement</code>
     * object, which must be an SQL <code>INSERT</code>, <code>UPDATE</code>
     * or <code>DELETE</code> statement; or an SQL statement that returns
     * nothing, such as a DDL statement.
     *
     * @return either (1) the row count for <code>INSERT</code>,
     *   <code>UPDATE</code>, or <code>DELETE</code> statements or (2) 0 for
     *   SQL statements that return nothing
     * @throws SQLException if a database access error occurs or the SQL
     *   statement returns a <code>ResultSet</code> object
     */
    public int executeUpdate()
        throws SQLException {
        int rv;
        this.doLog();
        rv  = pstmt.executeUpdate();
        return rv;
    }

    /**
     * Sets the designated parameter to SQL <code>NULL</code>.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param sqlType the SQL type code defined in
     *   <code>java.sql.Types</code>
     * @throws SQLException if a database access error occurs
     */
    public void setNull(int parameterIndex, int sqlType)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), null);
        this.pstmt.setNull(parameterIndex, sqlType);
    }

    /**
     * Sets the designated parameter to the given Java <code>boolean</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setBoolean(int parameterIndex, boolean x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), new Boolean(x));
        this.pstmt.setBoolean(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given Java <code>byte</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setByte(int parameterIndex, byte x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), new Byte(x));
        this.pstmt.setByte(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given Java <code>short</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setShort(int parameterIndex, short x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), new Short(x));
        this.pstmt.setShort(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given Java <code>int</code> value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setInt(int parameterIndex, int x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), Integer.valueOf(x));
        this.pstmt.setInt(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given Java <code>long</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setLong(int parameterIndex, long x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), Long.valueOf(x));
        this.pstmt.setLong(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given Java <code>float</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setFloat(int parameterIndex, float x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), Float.valueOf(x));
        this.pstmt.setFloat(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given Java <code>double</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setDouble(int parameterIndex, double x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), Double.valueOf(x));
        this.pstmt.setDouble(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given
     * <code>java.math.BigDecimal</code> value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setBigDecimal(int parameterIndex, BigDecimal x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setBigDecimal(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given Java <code>String</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setString(int parameterIndex, String x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setString(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given Java array of bytes.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setBytes(int parameterIndex, byte[] x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setBytes(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Date</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setDate(int parameterIndex, Date x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setDate(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Time</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setTime(int parameterIndex, Time x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setTime(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given
     * <code>java.sql.Timestamp</code> value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @throws SQLException if a database access error occurs
     */
    public void setTimestamp(int parameterIndex, Timestamp x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setTimestamp(parameterIndex, x);
    }

    /**
     * Sets the designated parameter to the given input stream, which will
     * have the specified number of bytes.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the Java input stream that contains the ASCII parameter value
     * @param length the number of bytes in the stream
     * @throws SQLException if a database access error occurs
     */
    public void setAsciiStream(int parameterIndex, InputStream x, int length)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setAsciiStream(parameterIndex, x, length);
    }

    /**
     * Sets the designated parameter to the given input stream, which will
     * have the specified number of bytes.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x a <code>java.io.InputStream</code> object that contains the
     *   Unicode parameter value as two-byte Unicode characters
     * @param length the number of bytes in the stream
     * @throws SQLException if a database access error occurs
     * @deprecated
     */
    public void setUnicodeStream(int parameterIndex, InputStream x, int length)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setUnicodeStream(parameterIndex, x, length);
    }

    /**
     * Sets the designated parameter to the given input stream, which will
     * have the specified number of bytes.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the java input stream which contains the binary parameter
     *   value
     * @param length the number of bytes in the stream
     * @throws SQLException if a database access error occurs
     */
    public void setBinaryStream(int parameterIndex, InputStream x, int length)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setBinaryStream(parameterIndex, x, length);
    }

    /**
     * Clears the current parameter values immediately.
     *
     * @throws SQLException if a database access error occurs
     */
    public void clearParameters()
        throws SQLException {
        this.params.clear();
        this.pstmt.clearParameters();
    }

    /**
     * <p>Sets the value of the designated parameter with the given object.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the object containing the input parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to
     *   be sent to the database. The scale argument may further qualify
     *   this type.
     * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC
     *   types, this is the number of digits after the decimal point. For
     *   all other types, this value will be ignored.
     * @throws SQLException if a database access error occurs
     */
    public void setObject(int parameterIndex, Object x, int targetSqlType,
        int scale)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setObject(parameterIndex, x, targetSqlType, scale);
    }

    /**
     * Sets the value of the designated parameter with the given object.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the object containing the input parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to
     *   be sent to the database
     * @throws SQLException if a database access error occurs
     */
    public void setObject(int parameterIndex, Object x, int targetSqlType)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setObject(parameterIndex, x, targetSqlType);
    }

    /**
     * <p>Sets the value of the designated parameter using the given object.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the object containing the input parameter value
     * @throws SQLException if a database access error occurs or the type of
     *   the given object is ambiguous
     */
    public void setObject(int parameterIndex, Object x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setObject(parameterIndex, x);
    }

    /**
     * Executes the SQL statement in this <code>PreparedStatement</code>
     * object, which may be any kind of SQL statement.
     *
     * @return <code>true</code> if the first result is a
     *   <code>ResultSet</code> object; <code>false</code> if the first
     *   result is an update count or there is no result
     * @throws SQLException if a database access error occurs or an argument
     *   is supplied to this method
     */
    public boolean execute()
        throws SQLException {
        boolean rv;
        this.doLog();
        rv  = this.pstmt.execute();
        return rv;
    }

    /**
     * Adds a set of parameters to this <code>PreparedStatement</code>
     * object's batch of commands.
     *
     * @throws SQLException if a database access error occurs
     */
    public void addBatch()
        throws SQLException {
        this.doLog();
        this.params.clear();
        this.pstmt.addBatch();
    }

    /**
     * Sets the designated parameter to the given <code>Reader</code> object,
     * which is the given number of characters long.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param reader the <code>java.io.Reader</code> object that contains
     *   the Unicode data
     * @param length the number of characters in the stream
     * @throws SQLException if a database access error occurs
     */
    public void setCharacterStream(int parameterIndex, Reader reader,
        int length)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), reader);
        this.pstmt.setCharacterStream(parameterIndex, reader, length);
    }

    /**
     * Sets the designated parameter to the given
     * <code>REF(&lt;structured-type&gt;)</code> value.
     *
     * @param i the first parameter is 1, the second is 2, ...
     * @param x an SQL <code>REF</code> value
     * @throws SQLException if a database access error occurs
     */
    public void setRef(int i, Ref x)
        throws SQLException {
        this.params.put(Integer.valueOf(i), x);
        this.pstmt.setRef(i, x);
    }

    /**
     * Sets the designated parameter to the given <code>Blob</code> object.
     *
     * @param i the first parameter is 1, the second is 2, ...
     * @param x a <code>Blob</code> object that maps an SQL
     *   <code>BLOB</code> value
     * @throws SQLException if a database access error occurs
     */
    public void setBlob(int i, Blob x)
        throws SQLException {
        this.params.put(Integer.valueOf(i), x);
        this.pstmt.setBlob(i, x);
    }

    /**
     * Sets the designated parameter to the given <code>Clob</code> object.
     *
     * @param i the first parameter is 1, the second is 2, ...
     * @param x a <code>Clob</code> object that maps an SQL
     *   <code>CLOB</code> value
     * @throws SQLException if a database access error occurs
     */
    public void setClob(int i, Clob x)
        throws SQLException {
        this.params.put(Integer.valueOf(i), x);
        this.pstmt.setClob(i, x);
    }

    /**
     * Sets the designated parameter to the given <code>Array</code> object.
     *
     * @param i the first parameter is 1, the second is 2, ...
     * @param x an <code>Array</code> object that maps an SQL
     *   <code>ARRAY</code> value
     * @throws SQLException if a database access error occurs
     */
    public void setArray(int i, Array x)
        throws SQLException {
        this.params.put(Integer.valueOf(i), x);
        this.pstmt.setArray(i, x);
    }

    /**
     * Retrieves a <code>ResultSetMetaData</code> object that contains
     * information about the columns of the <code>ResultSet</code> object
     * that will be returned when this <code>PreparedStatement</code> object
     * is executed.
     *
     * @return the description of a <code>ResultSet</code> object's columns
     *   or <code>null</code> if the driver cannot return a
     *   <code>ResultSetMetaData</code> object
     * @throws SQLException if a database access error occurs
     */
    public ResultSetMetaData getMetaData()
        throws SQLException {
        return this.pstmt.getMetaData();
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Date</code>
     * value, using the given <code>Calendar</code> object.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @param cal the <code>Calendar</code> object the driver will use to
     *   construct the date
     * @throws SQLException if a database access error occurs
     */
    public void setDate(int parameterIndex, Date x, Calendar cal)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setDate(parameterIndex, x, cal);
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Time</code>
     * value, using the given <code>Calendar</code> object.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @param cal the <code>Calendar</code> object the driver will use to
     *   construct the time
     * @throws SQLException if a database access error occurs
     */
    public void setTime(int parameterIndex, Time x, Calendar cal)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setTime(parameterIndex, x, cal);
    }

    /**
     * Sets the designated parameter to the given
     * <code>java.sql.Timestamp</code> value, using the given
     * <code>Calendar</code> object.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
     * @param cal the <code>Calendar</code> object the driver will use to
     *   construct the timestamp
     * @throws SQLException if a database access error occurs
     */
    public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setTimestamp(parameterIndex, x, cal);
    }

    /**
     * Sets the designated parameter to SQL <code>NULL</code>.
     *
     * @param paramIndex the first parameter is 1, the second is 2, ...
     * @param sqlType a value from <code>java.sql.Types</code>
     * @param typeName the fully-qualified name of an SQL user-defined type;
     *   ignored if the parameter is not a user-defined type or REF
     * @throws SQLException if a database access error occurs
     */
    public void setNull(int paramIndex, int sqlType, String typeName)
        throws SQLException {
        this.params.put(Integer.valueOf(paramIndex), null);
        this.pstmt.setNull(paramIndex, sqlType, typeName);
    }

    /**
     * Sets the designated parameter to the given <code>java.net.URL</code>
     * value.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the <code>java.net.URL</code> object to be set
     * @throws SQLException if a database access error occurs
     */
    public void setURL(int parameterIndex, URL x)
        throws SQLException {
        this.params.put(Integer.valueOf(parameterIndex), x);
        this.pstmt.setURL(parameterIndex, x);
    }

    /**
     * Retrieves the number, types and properties of this
     * <code>PreparedStatement</code> object's parameters.
     *
     * @return a <code>ParameterMetaData</code> object that contains
     *   information about the number, types and properties of this
     *   <code>PreparedStatement</code> object's parameters
     * @throws SQLException if a database access error occurs
     */
    public ParameterMetaData getParameterMetaData()
        throws SQLException {
        return this.pstmt.getParameterMetaData();
    }

    /**
     * Executes the given SQL statement, which returns a single
     * <code>ResultSet</code> object.
     *
     * @param sql an SQL statement to be sent to the database, typically a
     *   static SQL <code>SELECT</code> statement
     * @return a <code>ResultSet</code> object that contains the data
     *   produced by the given query; never <code>null</code>
     * @throws SQLException if a database access error occurs or the given
     *   SQL statement produces anything other than a single
     *   <code>ResultSet</code> object
     */
    public ResultSet executeQuery(String sql)
        throws SQLException {
        ResultSet   rv;
        this.doLog(sql);
        rv  = this.pstmt.executeQuery(sql);
        return rv;
    }

    /**
     * Executes the given SQL statement, which may be an <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>DELETE</code> statement or an SQL
     * statement that returns nothing, such as an SQL DDL statement.
     *
     * @param sql an SQL <code>INSERT</code>, <code>UPDATE</code> or
     *   <code>DELETE</code> statement or an SQL statement that returns
     *   nothing
     * @return either the row count for <code>INSERT</code>,
     *   <code>UPDATE</code> or <code>DELETE</code> statements, or
     *   <code>0</code> for SQL statements that return nothing
     * @throws SQLException if a database access error occurs or the given
     *   SQL statement produces a <code>ResultSet</code> object
     */
    public int executeUpdate(String sql)
        throws SQLException {
        int rv;
        this.doLog(sql);
        rv  = this.pstmt.executeUpdate(sql);
        return rv;
    }

    /**
     * Releases this <code>Statement</code> object's database and JDBC
     * resources immediately instead of waiting for this to happen when it is
     * automatically closed.
     *
     * @throws SQLException if a database access error occurs
     */
    public void close()
        throws SQLException {

        this.params.clear();
        this.pstmt.close();
    }

    /**
     * Retrieves the maximum number of bytes that can be returned for
     * character and binary column values in a <code>ResultSet</code> object
     * produced by this <code>Statement</code> object.
     *
     * @return the current column size limit for columns storing character
     *   and binary values; zero means there is no limit
     * @throws SQLException if a database access error occurs
     */
    public int getMaxFieldSize()
        throws SQLException {
        return this.pstmt.getMaxFieldSize();
    }

    /**
     * Sets the limit for the maximum number of bytes in a
     * <code>ResultSet</code> column storing character or binary values to
     * the given number of bytes.
     *
     * @param max the new column size limit in bytes; zero means there is no
     *   limit
     * @throws SQLException if a database access error occurs or the
     *   condition max >= 0 is not satisfied
     */
    public void setMaxFieldSize(int max)
        throws SQLException {
        this.pstmt.setMaxFieldSize(max);
    }

    /**
     * Retrieves the maximum number of rows that a <code>ResultSet</code>
     * object produced by this <code>Statement</code> object can contain.
     *
     * @return the current maximum number of rows for a
     *   <code>ResultSet</code> object produced by this
     *   <code>Statement</code> object; zero means there is no limit
     * @throws SQLException if a database access error occurs
     */
    public int getMaxRows()
        throws SQLException {
        return this.pstmt.getMaxRows();
    }

    /**
     * Sets the limit for the maximum number of rows that any
     * <code>ResultSet</code> object can contain to the given number.
     *
     * @param max the new max rows limit; zero means there is no limit
     * @throws SQLException if a database access error occurs or the
     *   condition max >= 0 is not satisfied
     */
    public void setMaxRows(int max)
        throws SQLException {
        this.setMaxRows(max);
    }

    /**
     * Sets escape processing on or off.
     *
     * @param enable <code>true</code> to enable escape processing;
     *   <code>false</code> to disable it
     * @throws SQLException if a database access error occurs
     */
    public void setEscapeProcessing(boolean enable)
        throws SQLException {
        this.pstmt.setEscapeProcessing(enable);
    }

    /**
     * Retrieves the number of seconds the driver will wait for a
     * <code>Statement</code> object to execute.
     *
     * @return the current query timeout limit in seconds; zero means there
     *   is no limit
     * @throws SQLException if a database access error occurs
     */
    public int getQueryTimeout()
        throws SQLException {
        return this.pstmt.getQueryTimeout();
    }

    /**
     * Sets the number of seconds the driver will wait for a
     * <code>Statement</code> object to execute to the given number of
     * seconds.
     *
     * @param seconds the new query timeout limit in seconds; zero means
     *   there is no limit
     * @throws SQLException if a database access error occurs or the
     *   condition seconds >= 0 is not satisfied
     */
    public void setQueryTimeout(int seconds)
        throws SQLException {
        this.pstmt.setQueryTimeout(seconds);
    }

    /**
     * Cancels this <code>Statement</code> object if both the DBMS and driver
     * support aborting an SQL statement.
     *
     * @throws SQLException if a database access error occurs
     */
    public void cancel()
        throws SQLException {
        this.pstmt.cancel();
    }

    /**
     * Retrieves the first warning reported by calls on this
     * <code>Statement</code> object.
     *
     * @return the first <code>SQLWarning</code> object or <code>null</code>
     *   if there are no warnings
     * @throws SQLException if a database access error occurs or this method
     *   is called on a closed statement
     */
    public SQLWarning getWarnings()
        throws SQLException {
        return this.pstmt.getWarnings();
    }

    /**
     * Clears all the warnings reported on this <code>Statement</code> object.
     *
     * @throws SQLException if a database access error occurs
     */
    public void clearWarnings()
        throws SQLException {
        this.pstmt.clearWarnings();
    }

    /**
     * Sets the SQL cursor name to the given <code>String</code>, which will
     * be used by subsequent <code>Statement</code> object
     * <code>execute</code> methods.
     *
     * @param name the new cursor name, which must be unique within a
     *   connection
     * @throws SQLException if a database access error occurs
     */
    public void setCursorName(String name)
        throws SQLException {
        this.pstmt.setCursorName(name);
    }

    /**
     * Executes the given SQL statement, which may return multiple results.
     *
     * @param sql any SQL statement
     * @return <code>true</code> if the first result is a
     *   <code>ResultSet</code> object; <code>false</code> if it is an
     *   update count or there are no results
     * @throws SQLException if a database access error occurs
     */
    public boolean execute(String sql)
        throws SQLException {
        boolean rv;
        this.doLog(sql);
        rv  = this.pstmt.execute(sql);
        return rv;
    }

    /**
     * Retrieves the current result as a <code>ResultSet</code> object.
     *
     * @return the current result as a <code>ResultSet</code> object or
     *   <code>null</code> if the result is an update count or there are no
     *   more results
     * @throws SQLException if a database access error occurs
     */
    public ResultSet getResultSet()
        throws SQLException {
        return this.pstmt.getResultSet();
    }

    /**
     * Retrieves the current result as an update count; if the result is a
     * <code>ResultSet</code> object or there are no more results, -1 is
     * returned.
     *
     * @return the current result as an update count; -1 if the current
     *   result is a <code>ResultSet</code> object or there are no more
     *   results
     * @throws SQLException if a database access error occurs
     */
    public int getUpdateCount()
        throws SQLException {
        int rv;

        rv  = this.pstmt.getUpdateCount();
        return rv;
    }

    /**
     * Moves to this <code>Statement</code> object's next result, returns
     * <code>true</code> if it is a <code>ResultSet</code> object, and
     * implicitly closes any current <code>ResultSet</code> object(s)
     * obtained with the method <code>getResultSet</code>.
     *
     * @return <code>true</code> if the next result is a
     *   <code>ResultSet</code> object; <code>false</code> if it is an
     *   update count or there are no more results
     * @throws SQLException if a database access error occurs
     */
    public boolean getMoreResults()
        throws SQLException {
        return this.pstmt.getMoreResults();
    }

    /**
     * Gives the driver a hint as to the direction in which rows will be
     * processed in <code>ResultSet</code> objects created using this
     * <code>Statement</code> object.
     *
     * @param direction the initial direction for processing rows
     * @throws SQLException if a database access error occurs or the given
     *   direction is not one of <code>ResultSet.FETCH_FORWARD</code>,
     *   <code>ResultSet.FETCH_REVERSE</code>, or
     *   <code>ResultSet.FETCH_UNKNOWN</code>
     */
    public void setFetchDirection(int direction)
        throws SQLException {
        this.pstmt.setFetchDirection(direction);
    }

    /**
     * Retrieves the direction for fetching rows from database tables that is
     * the default for result sets generated from this <code>Statement</code>
     * object.
     *
     * @return the default fetch direction for result sets generated from
     *   this <code>Statement</code> object
     * @throws SQLException if a database access error occurs
     */
    public int getFetchDirection()
        throws SQLException {
        return this.pstmt.getFetchDirection();
    }

    /**
     * Gives the JDBC driver a hint as to the number of rows that should be
     * fetched from the database when more rows are needed.
     *
     * @param rows the number of rows to fetch
     * @throws SQLException if a database access error occurs, or the
     *   condition 0 <= <code>rows</code> <= <code>this.getMaxRows()</code>
     *   is not satisfied.
     */
    public void setFetchSize(int rows)
        throws SQLException {
        this.pstmt.setFetchSize(rows);
    }

    /**
     * Retrieves the number of result set rows that is the default fetch size
     * for <code>ResultSet</code> objects generated from this
     * <code>Statement</code> object.
     *
     * @return the default fetch size for result sets generated from this
     *   <code>Statement</code> object
     * @throws SQLException if a database access error occurs
     */
    public int getFetchSize()
        throws SQLException {
        return this.pstmt.getFetchSize();
    }

    /**
     * Retrieves the result set concurrency for <code>ResultSet</code>
     * objects generated by this <code>Statement</code> object.
     *
     * @return either <code>ResultSet.CONCUR_READ_ONLY</code> or
     *   <code>ResultSet.CONCUR_UPDATABLE</code>
     * @throws SQLException if a database access error occurs
     */
    public int getResultSetConcurrency()
        throws SQLException {
        return this.pstmt.getResultSetConcurrency();
    }

    /**
     * Retrieves the result set type for <code>ResultSet</code> objects
     * generated by this <code>Statement</code> object.
     *
     * @return one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
     *   <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
     *   <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
     * @throws SQLException if a database access error occurs
     */
    public int getResultSetType()
        throws SQLException {
        return this.pstmt.getResultSetType();
    }

    /**
     * Adds the given SQL command to the current list of commmands for this
     * <code>Statement</code> object.
     *
     * @param sql typically this is a static SQL <code>INSERT</code> or
     *   <code>UPDATE</code> statement
     * @throws SQLException if a database access error occurs, or the driver
     *   does not support batch updates
     */
    public void addBatch(String sql)
        throws SQLException {
        this.doLog(sql);
        this.pstmt.addBatch(sql);
    }

    /**
     * Empties this <code>Statement</code> object's current list of SQL
     * commands.
     *
     * @throws SQLException if a database access error occurs or the driver
     *   does not support batch updates
     */
    public void clearBatch()
        throws SQLException {
        this.params.clear();
        this.pstmt.clearBatch();
    }

    /**
     * Submits a batch of commands to the database for execution and if all
     * commands execute successfully, returns an array of update counts.
     *
     * @return an array of update counts containing one element for each
     *   command in the batch. The elements of the array are ordered
     *   according to the order in which commands were added to the batch.
     * @throws SQLException if a database access error occurs or the driver
     *   does not support batch statements. Throws {@link
     *   BatchUpdateException} (a subclass of <code>SQLException</code>) if
     *   one of the commands sent to the database fails to execute properly
     *   or attempts to return a result set.
     */
    public int[] executeBatch()
        throws SQLException {
        return this.pstmt.executeBatch();
    }

    /**
     * Retrieves the <code>Connection</code> object that produced this
     * <code>Statement</code> object.
     *
     * @return the connection that produced this statement
     * @throws SQLException if a database access error occurs
     */
    public Connection getConnection()
        throws SQLException {
        return this.pstmt.getConnection();
    }

    /**
     * Moves to this <code>Statement</code> object's next result, deals with
     * any current <code>ResultSet</code> object(s) according to the
     * instructions specified by the given flag, and returns
     * <code>true</code> if the next result is a <code>ResultSet</code>
     * object.
     *
     * @param current one of the following <code>Statement</code> constants
     *   indicating what should happen to current <code>ResultSet</code>
     *   objects obtained using the method <code>getResultSet</code>:
     *   <code>Statement.CLOSE_CURRENT_RESULT</code>,
     *   <code>Statement.KEEP_CURRENT_RESULT</code>, or
     *   <code>Statement.CLOSE_ALL_RESULTS</code>
     * @return <code>true</code> if the next result is a
     *   <code>ResultSet</code> object; <code>false</code> if it is an
     *   update count or there are no more results
     * @throws SQLException if a database access error occurs or the
     *   argument supplied is not one of the following:
     *   <code>Statement.CLOSE_CURRENT_RESULT</code>,
     *   <code>Statement.KEEP_CURRENT_RESULT</code>, or
     *   <code>Statement.CLOSE_ALL_RESULTS</code>
     */
    public boolean getMoreResults(int current)
        throws SQLException {
        return this.pstmt.getMoreResults(current);
    }

    /**
     * Retrieves any auto-generated keys created as a result of executing
     * this <code>Statement</code> object.
     *
     * @return a <code>ResultSet</code> object containing the auto-generated
     *   key(s) generated by the execution of this <code>Statement</code>
     *   object
     * @throws SQLException if a database access error occurs
     */
    public ResultSet getGeneratedKeys()
        throws SQLException {
        return this.pstmt.getGeneratedKeys();
    }

    /**
     * Executes the given SQL statement and signals the driver with the given
     * flag about whether the auto-generated keys produced by this
     * <code>Statement</code> object should be made available for retrieval.
     *
     * @param sql must be an SQL <code>INSERT</code>, <code>UPDATE</code> or
     *   <code>DELETE</code> statement or an SQL statement that returns
     *   nothing
     * @param autoGeneratedKeys a flag indicating whether auto-generated
     *   keys should be made available for retrieval; one of the following
     *   constants: <code>Statement.RETURN_GENERATED_KEYS</code>
     *   <code>Statement.NO_GENERATED_KEYS</code>
     * @return either the row count for <code>INSERT</code>,
     *   <code>UPDATE</code> or <code>DELETE</code> statements, or
     *   <code>0</code> for SQL statements that return nothing
     * @throws SQLException if a database access error occurs, the given SQL
     *   statement returns a <code>ResultSet</code> object, or the given
     *   constant is not one of those allowed
     */
    public int executeUpdate(String sql, int autoGeneratedKeys)
        throws SQLException {
//        this.doLog("update", sql, String.valueOf(autoGeneratedKeys));
    	this.doLog(sql);
        return this.pstmt.executeUpdate(sql, autoGeneratedKeys);
    }

    /**
     * Executes the given SQL statement and signals the driver that the
     * auto-generated keys indicated in the given array should be made
     * available for retrieval.
     *
     * @param sql an SQL <code>INSERT</code>, <code>UPDATE</code> or
     *   <code>DELETE</code> statement or an SQL statement that returns
     *   nothing, such as an SQL DDL statement
     * @param columnIndexes an array of column indexes indicating the
     *   columns that should be returned from the inserted row
     * @return either the row count for <code>INSERT</code>,
     *   <code>UPDATE</code>, or <code>DELETE</code> statements, or 0 for
     *   SQL statements that return nothing
     * @throws SQLException if a database access error occurs, the SQL
     *   statement returns a <code>ResultSet</code> object, or the second
     *   argument supplied to this method is not an <code>int</code> array
     *   whose elements are valid column indexes
     */
    public int executeUpdate(String sql, int[] columnIndexes)
        throws SQLException {
//        this.doLog("update", sql, columnIndexes.toString());
    	this.doLog(sql);
        return this.pstmt.executeUpdate(sql, columnIndexes);
    }

    /**
     * Executes the given SQL statement and signals the driver that the
     * auto-generated keys indicated in the given array should be made
     * available for retrieval.
     *
     * @param sql an SQL <code>INSERT</code>, <code>UPDATE</code> or
     *   <code>DELETE</code> statement or an SQL statement that returns
     *   nothing
     * @param columnNames an array of the names of the columns that should
     *   be returned from the inserted row
     * @return either the row count for <code>INSERT</code>,
     *   <code>UPDATE</code>, or <code>DELETE</code> statements, or 0 for
     *   SQL statements that return nothing
     * @throws SQLException if a database access error occurs, the SQL
     *   statement returns a <code>ResultSet</code> object, or the second
     *   argument supplied to this method is not a <code>String</code> array
     *   whose elements are valid column names
     */
    public int executeUpdate(String sql, String[] columnNames)
        throws SQLException {
//        this.doLog("update", sql, columnNames.toString());
    	this.doLog(sql);
        return this.pstmt.executeUpdate(sql, columnNames);
    }

    /**
     * Executes the given SQL statement, which may return multiple results,
     * and signals the driver that any auto-generated keys should be made
     * available for retrieval.
     *
     * @param sql any SQL statement
     * @param autoGeneratedKeys a constant indicating whether auto-generated
     *   keys should be made available for retrieval using the method
     *   <code>getGeneratedKeys</code>; one of the following constants:
     *   <code>Statement.RETURN_GENERATED_KEYS</code> or
     *   <code>Statement.NO_GENERATED_KEYS</code>
     * @return <code>true</code> if the first result is a
     *   <code>ResultSet</code> object; <code>false</code> if it is an
     *   update count or there are no results
     * @throws SQLException if a database access error occurs or the second
     *   parameter supplied to this method is not
     *   <code>Statement.RETURN_GENERATED_KEYS</code> or
     *   <code>Statement.NO_GENERATED_KEYS</code>.
     */
    public boolean execute(String sql, int autoGeneratedKeys)
        throws SQLException {
//        this.doLog("execute", sql, String.valueOf(autoGeneratedKeys));
    	this.doLog(sql);
        return this.pstmt.execute(sql, autoGeneratedKeys);
    }

    /**
     * Executes the given SQL statement, which may return multiple results,
     * and signals the driver that the auto-generated keys indicated in the
     * given array should be made available for retrieval.
     *
     * @param sql any SQL statement
     * @param columnIndexes an array of the indexes of the columns in the
     *   inserted row that should be made available for retrieval by a call
     *   to the method <code>getGeneratedKeys</code>
     * @return <code>true</code> if the first result is a
     *   <code>ResultSet</code> object; <code>false</code> if it is an
     *   update count or there are no results
     * @throws SQLException if a database access error occurs or the
     *   elements in the <code>int</code> array passed to this method are
     *   not valid column indexes
     */
    public boolean execute(String sql, int[] columnIndexes)
        throws SQLException {
//        this.doLog("execute", sql, columnIndexes.toString());
    	this.doLog(sql);
        return this.pstmt.execute(sql, columnIndexes);
    }

    /**
     * Executes the given SQL statement, which may return multiple results,
     * and signals the driver that the auto-generated keys indicated in the
     * given array should be made available for retrieval.
     *
     * @param sql any SQL statement
     * @param columnNames an array of the names of the columns in the
     *   inserted row that should be made available for retrieval by a call
     *   to the method <code>getGeneratedKeys</code>
     * @return <code>true</code> if the next result is a
     *   <code>ResultSet</code> object; <code>false</code> if it is an
     *   update count or there are no more results
     * @throws SQLException if a database access error occurs or the
     *   elements of the <code>String</code> array passed to this method are
     *   not valid column names
     */
    public boolean execute(String sql, String[] columnNames)
        throws SQLException {
//        this.doLog("execute", sql, columnNames.toString());
    	this.doLog(sql);
        return this.pstmt.execute(sql, columnNames);
    }

    /**
     * Retrieves the result set holdability for <code>ResultSet</code>
     * objects generated by this <code>Statement</code> object.
     *
     * @return either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
     *   <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
     * @throws SQLException if a database access error occurs
     */
    public int getResultSetHoldability()
        throws SQLException {
        return this.pstmt.getResultSetHoldability();
    }

	public void setBlob(int parameterIndex, InputStream inputStream)
			throws SQLException {
		this.params.put(Integer.valueOf(parameterIndex), inputStream);
		this.setBlob(parameterIndex, inputStream);
	}

	public void setNClob(int parameterIndex, Reader reader)
			throws SQLException {
		this.params.put(Integer.valueOf(parameterIndex), reader);
		this.setNClob(parameterIndex, reader);
	}

	public boolean isClosed() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	public void setPoolable(boolean poolable) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public boolean isPoolable() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	public <T> T unwrap(Class<T> iface) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	public void setRowId(int parameterIndex, RowId x) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setNString(int parameterIndex, String value)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setNCharacterStream(int parameterIndex, Reader value,
			long length) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setNClob(int parameterIndex, NClob value) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setBlob(int parameterIndex, InputStream inputStream, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setNClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setSQLXML(int parameterIndex, SQLXML xmlObject)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setAsciiStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setBinaryStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setCharacterStream(int parameterIndex, Reader reader,
			long length) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setAsciiStream(int parameterIndex, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setBinaryStream(int parameterIndex, InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setCharacterStream(int parameterIndex, Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setNCharacterStream(int parameterIndex, Reader value)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setClob(int parameterIndex, Reader reader) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void closeOnCompletion() throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public boolean isCloseOnCompletion() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}
}
